package de.uni.bamberg.wiai.minf.forflow.datagenerator.view.dialog;

import java.awt.Component;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;
import java.util.List;

import javax.swing.AbstractAction;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JTable;
import javax.swing.KeyStroke;
import javax.swing.table.AbstractTableModel;
import javax.swing.table.TableCellRenderer;
import javax.swing.table.TableColumn;

import org.jdesktop.application.Action;

import de.uni.bamberg.wiai.minf.forflow.datagenerator.controller.ControllerFactory;
import de.uni.bamberg.wiai.minf.forflow.datagenerator.model.datastructure.FacetSimplified;

/**
 * <b>NullValues</b> class shows a dialog in which a list of
 * possible facets are shown. The purpose of this dialog is to
 * define or specify those facets, which are allowed to have
 * null values in generated test data sets.
 * </p>
 * Please notice, the definition has an global effect to facets and
 * is not intended to be local.
 * </p>
 * Simple put - the reason why a global approach is used - one has
 * to specify the corresponding facets only once and for all, instead
 * of doing this task in each artefact.
 * </p>
 * Another thing to mention is, not all facets are allowed to have
 * null values in its later test data. Because it's not possible to
 * define those facets which are allowed at coding time, this has to be
 * done at runtime.
 * </p>
 * The dialog provides two methods: an accept and a cancel method.
 * If you click the <i>OK</i> button, the accept method is invoked and
 * the facets are marked accordingly to your choices.
 * 
 * @author Michael Munz
 * @version 0.1
 * @since Apr/05/09
 */
public class NullValues extends JDialog
{
	/**
	 * ID generated by Eclipse
	 */
	private static final long serialVersionUID = -624633069742523482L;
	
	/**
	 * customizes the used table model to a more sophisticated one.
	 */
	private CustomizedTableModel tabeModel_nullValues = null;
	
	/**
	 * The constructor passes the main frame and initializes its
	 * corresponding components.
	 * 
	 * @param parent
	 * 		it's the main frame. Usually it is the frame of the application framework.
	 */
	public NullValues(Frame parent)
	{
		super(parent);
		
		this.keyBinding();
		
		this.initCompBefore();
		
		// used by Netbeans
		this.initComponents();
		
		this.initCompAfter();
	}
	
	/**
	 * a work-around for Netbeans {@link #initComponents()} method.
	 */
	private void initCompBefore()
	{
		this.tabeModel_nullValues = new CustomizedTableModel();
	}
	
	/**
	 * a work-around for Netbeans {@link #initComponents()} method.
	 */
	private void initCompAfter()
	{
		// use good column sizes right from the beginning
		this.tabeModel_nullValues.initColumnSizes(this.table_nullValues);
	}
	
	/**
	 * initializes the key binding on the focused window.
	 * When the <i>ESC</i> button has been pressed, the dialog
	 * is gonna be closed or disposed respectively.
	 */
	private void keyBinding()
	{
		this.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(
				KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0),
				"cancel");
		this.getRootPane().getActionMap().put("cancel", new EscAction());
	}
	
	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        scrollPane_nullValues = new javax.swing.JScrollPane();
        table_nullValues = new javax.swing.JTable();
        button_ok = new javax.swing.JButton();
        label_headline = new javax.swing.JLabel();
        button_cancel = new javax.swing.JButton();
        label_description = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(de.uni.bamberg.wiai.minf.forflow.datagenerator.DataGenerator.class).getContext().getResourceMap(NullValues.class);
        setTitle(resourceMap.getString("Form.title")); // NOI18N
        setMinimumSize(new java.awt.Dimension(395, 300));
        setModalityType(ModalityType.APPLICATION_MODAL);
        setResizable(false);

        scrollPane_nullValues.setHorizontalScrollBarPolicy(javax.swing.ScrollPaneConstants.HORIZONTAL_SCROLLBAR_ALWAYS);
        scrollPane_nullValues.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
        scrollPane_nullValues.setName("scrollPane_nullValues"); // NOI18N

        table_nullValues.setModel(this.tabeModel_nullValues);
        table_nullValues.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
        table_nullValues.setName("table_nullValues"); // NOI18N
        scrollPane_nullValues.setViewportView(table_nullValues);

        javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance(de.uni.bamberg.wiai.minf.forflow.datagenerator.DataGenerator.class).getContext().getActionMap(NullValues.class, this);
        button_ok.setAction(actionMap.get("accept")); // NOI18N
        button_ok.setText(resourceMap.getString("button_ok.text")); // NOI18N
        button_ok.setName("button_ok"); // NOI18N

        label_headline.setFont(resourceMap.getFont("label_headline.font")); // NOI18N
        label_headline.setText(resourceMap.getString("label_headline.text")); // NOI18N
        label_headline.setName("label_headline"); // NOI18N

        button_cancel.setAction(actionMap.get("cancel")); // NOI18N
        button_cancel.setText(resourceMap.getString("button_cancel.text")); // NOI18N
        button_cancel.setName("button_cancel"); // NOI18N

        label_description.setText(resourceMap.getString("label_description.text")); // NOI18N
        label_description.setName("label_description"); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(107, 107, 107)
                        .addComponent(label_headline))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(label_description, javax.swing.GroupLayout.DEFAULT_SIZE, 375, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(scrollPane_nullValues, javax.swing.GroupLayout.DEFAULT_SIZE, 375, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(114, 114, 114)
                        .addComponent(button_ok)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(button_cancel)))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {button_cancel, button_ok});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(label_headline)
                .addGap(18, 18, 18)
                .addComponent(label_description)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(scrollPane_nullValues, javax.swing.GroupLayout.PREFERRED_SIZE, 148, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(button_ok)
                    .addComponent(button_cancel))
                .addContainerGap(12, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

	/**
	 * causing this method, the selected facets are marked
	 * to have possible null values in the generated test data sets.
	 * There's no need to validate the input, because it is the testers
	 * responsibility.
	 * It's not that the system couldn't do it, but it is impossible to
	 * validate any facet at runtime.
	 */
    @Action
    public void accept()
    {
    	ControllerFactory.getControllerBackgroundTask().saveNullValues(
    			this,
    			this.tabeModel_nullValues.data);
    }

    /**
     * Of course, it's possible to cancel the task and close the
     * dialog without doing anything without changing the data model.
     * If you wanna leave this dialog without saving your made up choices,
     * do that with this method.
     */
    @Action
    public void cancel()
    {
    	this.dispose();
    }
    
    /**
     * sets the table data for this dialog table.
     * The object should look like this:
     * <pre>
     * tableData = {{"attribute 1", "Class", new Boolean(NULL?), "Type"},
     *              {"attribute 2", "Class", new Boolean(NULL?), "Type"},
     *              ...};
     * </pre>
     * The 1st column lists all facets. Depending on the EMF Ecore model
     * there could be same attributes more than once listed. To make clear
     * which attribute it is the corresponding class name is in the 2nd column.
     * In the 3rd column are the flags and define facets to have either null values or not.
     * The 4th and last column is for maintaining only and won't be displayed.
     * It states the artefact type of a facet.
     * 
     * @param tableData
     * 		 attributes of all artefact classes.
     */
    public void setData(List<FacetSimplified> tableData)
    {
    	this.tabeModel_nullValues.data = tableData;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton button_cancel;
    private javax.swing.JButton button_ok;
    private javax.swing.JLabel label_description;
    private javax.swing.JLabel label_headline;
    private javax.swing.JScrollPane scrollPane_nullValues;
    private javax.swing.JTable table_nullValues;
    // End of variables declaration//GEN-END:variables
    
   /**
    * Handles the action event, when button <i>ESC</i> has been pressed.
    * This is done by key binding to respond within the focused window.
    * </p>
    * When <i>ESC</i> is pressed, the dialog is gonna be disposed.
    * 
    * @author Michael Munz
    * @version 0.1
    * @since Apr/09/09
    */
    private class EscAction extends AbstractAction
	{
		/**
		 * ID generated by Eclipse
		 */
		private static final long serialVersionUID = 3220772354792020383L;

		@Override
		public void actionPerformed(ActionEvent ae)
		{
			dispose();
		}
	}
    
    /**
     * Customized table model allows to specify how data should
     * be represented and how columns are handled.
     * 
     * @author Michael Munz
     * @version 0.1
     * @since Apr/13/09
     */
    private class CustomizedTableModel extends AbstractTableModel
    {
		/**
		 * ID generated by Eclipse
		 */
		private static final long serialVersionUID = -827643340220331712L;
		
		/**
		 * defines the column names of this table model
		 */
		private String[] columnNames = {"Facet",
										"Where to find",
										"Is NULL allowed?"};
		
		/**
		 * holds the table data
		 */
		private List<FacetSimplified> data = null;
		
		@Override
		public int getColumnCount()
		{
			return this.columnNames.length;
		}
		
		@Override
		public String getColumnName(int column)
		{
			return this.columnNames[column];
		}
		
		@Override
		public Class<?> getColumnClass(int column)
		{
			switch(column)
			{
				// facet
				case 0:
					return String.class;
				
				// where to find
				case 1:
					return String.class;
				
				// null?
				case 2:
					return Boolean.class;
					
				// else
				default:
					return null;
			}
		}
		
		@Override
		public int getRowCount()
		{
			if(this.data != null)
			{
				return this.data.size();
			}
			else
			{
				return -1;
			}
		}

		@Override
		public void setValueAt(Object value, int row, int column)
		{
			if(this.data != null)
			{
				FacetSimplified fs = this.data.get(row);
				
				switch(column)
				{
					// facet
					case 0:
						fs.setAttributeName((String) value);
						break;
					
					// where to find
					case 1:
						fs.setClassName((String) value);
						break;
					
					// null?
					case 2:
						fs.isNullAllowed((Boolean) value);
						break;
					
					// else
					default:
						break;
				}
				
				// replace it
				this.data.set(row, fs);
			}
			
			this.fireTableCellUpdated(row, column);
			this.updateColumnSize(table_nullValues, row, column);
		}
		
		@Override
		public Object getValueAt(int row, int column)
		{
			if(this.data != null)
			{
				FacetSimplified mAttribute = this.data.get(row);
				
				switch(column)
				{
					// facet
					case 0:
						return mAttribute.getAttributeName();
					
					// where to find
					case 1:
						return mAttribute.getClassName();
					
					// null?
					case 2:
						return mAttribute.isNullAllowed();
						
					// else
					default:
						return null;
				}
			}
			else
			{
				return null;
			}
		}
		
		@Override
		public boolean isCellEditable(int row, int column)
		{
			if(this.getColumnName(column).equals(this.columnNames[2]))
			{
				return true;
			}
			else
			{
				return false;
			}
		}
		
		@Override
		public void fireTableDataChanged()
		{
			super.fireTableDataChanged();
		}
		
		/**
		 * This method picks good column sizes.
		 * If column heads are wider than the column's cells'
		 * contents, then this size is used. Otherwise
		 * the cell's size is taken.
		 * 
		 * @param table
		 * 		table to adjust the columns' sizes
		 */
		private void initColumnSizes(JTable table)
		{
			TableColumn column = null;
			Component comp = null;
			
			int headerWidth = 0;
			int cellWidth = 0;
			
			TableCellRenderer headerRenderer = table.getTableHeader().getDefaultRenderer();
			
			for(int i=0; i<this.getColumnCount(); i++)
			{
				column = table.getColumnModel().getColumn(i);
				
				comp = headerRenderer.getTableCellRendererComponent(
						table,
						column.getHeaderValue(),
						false,
						false,
						0, 
						0);
				
				headerWidth = comp.getPreferredSize().width +10;
				
				Object maxOb = null;
				int row = 0;
				
				// find the object with the max. length
				if(this.data != null)
				{
					for(int j=0; j<this.data.size(); j++)
					{
						Object tmpOb = this.getValueAt(j, i);
						
						if(maxOb == null)
						{
							maxOb = tmpOb;
							
							row = j;
						}
						else
						{
							if(String.valueOf(maxOb).length() < String.valueOf(tmpOb).length())
							{
								maxOb = tmpOb;
								
								row = j;
							}
						}
					}
				}
				
				comp = table.getDefaultRenderer(this.getColumnClass(i)).getTableCellRendererComponent(
						table,
						maxOb,
						false,
						false,
						row,
						i);
				
				cellWidth = comp.getPreferredSize().width +10;
				
				column.setPreferredWidth(Math.max(headerWidth, cellWidth));
			}
		}
		
		 /**
         * this method is like {@link #initColumnSizes(JTable)}.
         * Instead of initializing the whole table with a
         * good column size, we just update the column size at
         * a specific column.
         * </p>
         * This happens usually, when values change in the table
         * we update that column to have still a good column size.
         * 
         * @param table
         * 		that's the table to update. It has to be updated when
         * 		values change within. The update is necessary to get
         * 		good column sizes again. But we update only that column
         * 		where the changed had happened.
         * @param row
         * 		the row where the data changed.
         * @param column
         * 		the column to update in width to get a good display feeling.
         */
        private void updateColumnSize(JTable table, int row, int column)
        {
        	TableColumn col = table.getColumnModel().getColumn(column);
        	Component comp = null;
        	
        	int headerWidth = 0;
        	int cellWidth = 0;
        	
        	TableCellRenderer headerRenderer = table.getTableHeader().getDefaultRenderer();
        	
        	comp = headerRenderer.getTableCellRendererComponent(
        			table,
        			col.getHeaderValue(),
        			false,
        			false,
        			0,
        			0);
        	
        	headerWidth = comp.getPreferredSize().width +10;
        	
        	comp = table.getDefaultRenderer(this.getColumnClass(column)).getTableCellRendererComponent(
        			table,
        			this.getValueAt(row, column),
        			false,
        			false,
        			row,
        			column);
        	
        	cellWidth = comp.getPreferredSize().width +10;
        	
        	col.setPreferredWidth(Math.max(headerWidth, cellWidth));
        }
    }
}