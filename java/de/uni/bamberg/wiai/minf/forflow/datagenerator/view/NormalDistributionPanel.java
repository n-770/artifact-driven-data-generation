package de.uni.bamberg.wiai.minf.forflow.datagenerator.view;

import java.util.logging.Level;

import javax.swing.JSpinner;
import javax.swing.SpinnerModel;
import javax.swing.SpinnerNumberModel;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;

import de.uni.bamberg.wiai.minf.forflow.datagenerator.controller.datageneration.distribution.NormalDistribution;
import de.uni.bamberg.wiai.minf.forflow.datagenerator.controller.datageneration.distribution.ProbabilityDistribution;
import de.uni.bamberg.wiai.minf.forflow.datagenerator.view.message.ErrorMessage;

/**
 * This is an representation of parameters of the Normal
 * probability distribution. A normal distribution has
 * two parameters, <i>expectation</i> and <i>variance</i>.
 * </p>
 * <font size=2><b>Parameters</b></font></br>
 * E(X) = &mu; </br>
 * &sigma; = &radic;Var(X)
 * </p>
 * For detailed informations about Normal probability distribution
 * see {@link NormalDistribution}.
 * 
 * @author Michael Munz
 * @version 0.1
 * @since May/06/09
 */
public class NormalDistributionPanel extends DistributionParameterPanel
{
	/**
	 * ID generated by Eclispe
	 */
	private static final long serialVersionUID = 7344553738791383051L;
	
	/**
	 * constructor is passed the probability distribution to which
	 * it belongs. This is because, we have to pass on the typed in
	 * values.
	 */
	public NormalDistributionPanel(ProbabilityDistribution distribution)
	{
		this.setDistribution(distribution);
		
		this.initBefore();
		
		this.initComponents();
		
		this.initAfter();
	}
	
	/**
	 * constructor is passed the probability distribution and the 
	 * parent panel. Remember, this is a panel for a specific
	 * probability distribution and is itself only a sub-panel.
	 * </p>
	 * <font size=2><b>Distribution</b></font></br>
	 * This is the probability distribution of this panel.
	 * The panel is responsible for updating typed in values
	 * and changes to that distribution. Because there're many
	 * different distributions available, one for all can't be
	 * realized. So there is one parameter panel for one distribution.
	 * </p>
	 * <font size=2><b>Distribution panel</b></font></br>
	 * This is the parent panel and holds all available probability
	 * distributions. When a particular distribution is selected by
	 * the tester, it gets the corresponding parameter panel.
	 * The parameter panel (this) is only responsible for the parameter
	 * settings like <i>expectation</i> or <i>variance</i>.
	 * When an update occrus down here, it has to call its parent
	 * which in turn calls its parent, too. In other words, the
	 * <i>chain of responsibility</i> is followed.
	 * 
	 * @param distribution
	 * 		that's the distribution this panel is responsible for
	 * @param panel
	 * 		the parent panel. We have to send update calls up here.
	 */
	public NormalDistributionPanel(ProbabilityDistribution distribution, DistributionPanel panel)
	{
		this.setDistribution(distribution);
		this.setDistributionPanel(panel);
		
		this.initBefore();
		
		this.initComponents();
		
		this.initAfter();
	}
	
	/**
	 * work-around of Netbeans {@link #initComponents()} method.
	 * This method is called before.
	 */
	private void initBefore()
	{
	}
	
	/**
	 * work-around of Netbeans {@link #initComponents()} method.
	 * This method is called after that mentioned.
	 */
	private void initAfter()
	{
		this.initSpinnerExpectation();
		
		this.initSpinnerStandardDeviation();
	}
	
	/**
	 * initializes the spinner of expectation.
	 * </p>
	 * <font size=2><b>SpinnerModel</b></font></br>
	 * First an default model is used at this point,
	 * because we don't know the values, yet.
	 * The default model is gonna be substituted by
	 * a custom model when the values are available.
	 * </p>
	 * <font size=2><b>ChangeListener</b></font></br>
	 * A change listener is added to notify the 
	 * probability distribution to take the new value.
	 * </p>
	 * <font size=2><b>Clone</b></font></br>
	 * Whenever a change here happens a clone object
	 * of the distribution this panel is responsible for
	 * is gonna be created. That is, 'cos we've to set
	 * the values many times. And if we use each time
	 * the same instance, we use also the same values.
	 * This is avoided by this approach. The cloned object
	 * gets the latest values and is send to the parent
	 * panel by an update call. We call the parent, rather
	 * to set the distribution by ourself, because
	 * otherwise we would violate the <i>chain of responsibility</i>.
	 */
	private void initSpinnerExpectation()
	{
		// model
		SpinnerModel model = new SpinnerNumberModel();
		
		this.spinner_expectation.setModel(model);
		
		// change listener
		this.spinner_expectation.addChangeListener(new ChangeListener()
		{
			@Override
			public void stateChanged(ChangeEvent ce)
			{
				NormalDistribution dist = (NormalDistribution) getDistribution();
				
				NormalDistribution clone = null;
				
				try
				{
					clone = (NormalDistribution) dist.clone();
				}
				catch(CloneNotSupportedException cnse)
				{
					ErrorMessage.getInstance().printMessage(cnse, "CloneNotSupportedException", Level.SEVERE);
				}
				
				// set latest values
				clone.setExpectation(getValue(spinner_expectation));
				clone.setStandardDeviation(getValue(spinner_standardDeviation));
				
				// send update
				getDistributionPanel().updateAndSetValues(clone, true);
			}
		});
	}
	
	/**
	 * initializes the spinner of standard deviation.
	 * </p>
	 * <font size=2><b>SpinnerModel</b></font></br>
	 * First an default model is used at this point,
	 * because we don't know the values, yet.
	 * The default model is gonna be substituted by
	 * a custom model when the values are available.
	 * </p>
	 * <font size=2><b>ChangeListener</b></font></br>
	 * Each time the values changes a change value event
	 * notifies the probability distribution.
	 * </p>
	 * <font size=2><b>Clone</b></font></br>
	 * Whenever a change here happens a clone object
	 * of the distribution this panel is responsible for
	 * is gonna be created. That is, 'cos we've to set
	 * the values many times. And if we use each time
	 * the same instance, we use also the same values.
	 * This is avoided by this approach. The cloned object
	 * gets the latest values and is send to the parent
	 * panel by an update call. We call the parent, rather
	 * to set the distribution by ourself, because
	 * otherwise we would violate the <i>chain of responsibility</i>.
	 */
	private void initSpinnerStandardDeviation()
	{
		// change listener
		this.spinner_standardDeviation.addChangeListener(new ChangeListener()
		{
			@Override
			public void stateChanged(ChangeEvent ce)
			{
				NormalDistribution dist = (NormalDistribution) getDistribution();
				
				NormalDistribution clone = null;
				
				try
				{
					clone = (NormalDistribution) dist.clone();
				}
				catch(CloneNotSupportedException cnse)
				{
					ErrorMessage.getInstance().printMessage(cnse, "CloneNotSupportedException");
				}
				
				// set latest values
				clone.setExpectation(getValue(spinner_expectation));
				clone.setStandardDeviation(getValue(spinner_standardDeviation));
				
				// send out an update
				getDistributionPanel().updateAndSetValues(clone, true);
			}
		});
	}
	
	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        label_expectation = new javax.swing.JLabel();
        label_standardDeviation = new javax.swing.JLabel();
        spinner_expectation = new javax.swing.JSpinner();
        spinner_standardDeviation = new javax.swing.JSpinner();

        setName("Form"); // NOI18N
        setPreferredSize(new java.awt.Dimension(154, 97));

        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(de.uni.bamberg.wiai.minf.forflow.datagenerator.DataGenerator.class).getContext().getResourceMap(NormalDistributionPanel.class);
        label_expectation.setText(resourceMap.getString("label_expectation.text")); // NOI18N
        label_expectation.setName("label_expectation"); // NOI18N

        label_standardDeviation.setText(resourceMap.getString("label_standardDeviation.text")); // NOI18N
        label_standardDeviation.setName("label_standardDeviation"); // NOI18N

        spinner_expectation.setName("spinner_expectation"); // NOI18N

        spinner_standardDeviation.setName("spinner_standardDeviation"); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(spinner_expectation, javax.swing.GroupLayout.PREFERRED_SIZE, 134, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(label_standardDeviation, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(spinner_standardDeviation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(label_expectation, javax.swing.GroupLayout.PREFERRED_SIZE, 102, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {spinner_expectation, spinner_standardDeviation});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(label_expectation, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(spinner_expectation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(label_standardDeviation)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(spinner_standardDeviation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * gets the typed in value of any spinner model
     * available in this panel.
     * 
     * @param spinner
     * 		the text field to get the latest value
     * @return
     * 		intValue()
     */
    private int getValue(JSpinner spinner)
    {
    	SpinnerNumberModel model = (SpinnerNumberModel) spinner.getModel();
    	
    	return model.getNumber().intValue();
    }
    
    /**
	 * initializes the spinner model for <i>Expectation</i>.
	 * This process happens usually, when the fill behaviour changes.
	 * The spinner model has to reflect that change and make sure only
	 * valid values are available.
	 * 
	 * @param initValue
	 * 		sets the current value
	 * @param N
	 * 		the total amount of values.
	 * 		Because this is in terms of a probability distribution,
	 * 		we refer to it as <i>X</i>.
	 * @param step
	 * 		the stepping
	 */
	protected void changeSpinnerModel_Expectation(int initValue, int N, int step)
	{
		int[] min_max = this.getMinMax(N);
		
		SpinnerModel model = new SpinnerNumberModel(initValue,
													min_max[0],
													min_max[1],
													step);
		
		this.spinner_expectation.setModel(model);
	}
	
	/**
	 * creates & sets the spinner model for standard derivation.
	 * It creates the stepping, min, max and initial value.
	 * This process happens usually, when the fill behaviour changes.
	 * The spinner model has to reflect that change and make sure only
	 * valid values are available.
	 * 
	 * @param initValue
	 * 		initial value to display
	 * @param N
	 * 		the total amount of values.
	 * 		Because this is in terms of a probability distribution,
	 * 		we refer to it as <i>X</i>.
	 * @param step
	 * 		the stepping
	 */
	protected void changeSpinnerModel_StandardDerivation(int initValue, int N, int step)
	{
		int[] min_max = this.getMinMax(N);
		
		SpinnerModel model = new SpinnerNumberModel(initValue, min_max[0], min_max[1], step);
		
		this.spinner_standardDeviation.setModel(model);
	}
    
	@Override
	protected void resetInputFields()
	{
		NormalDistribution normal = (NormalDistribution) this.getDistribution();
		
		// E(X)
		this.spinner_expectation.setValue(normal.getExpectation());
		
		// &sigma;
		this.spinner_standardDeviation.setValue(normal.getStandardDeviation());
	}
	
	/**
	 * sets the expectation and the standard deviation.
	 * Both are integer to they're casted down.
	 * </p>
	 * values[0] = E(X) </br>
	 * values[1] = &sigma;
	 */
	@Override
	protected void setValues(double[] values)
	{
		this.spinner_expectation.setValue((int) values[0]);
		this.spinner_standardDeviation.setValue((int) values[1]);
	}
	
	/**
	 * gets expectation
	 * 
	 * @return
	 * 		E(X) = &mu;
	 */
	protected int getExpectation()
	{
		return this.getValue(this.spinner_expectation);
	}
	
	/**
	 * gets standard deviation
	 * 
	 * @return
	 * 		&sigma; = &radic;Var(X)
	 */
	protected int getStandardDeviation()
	{
		return this.getValue(this.spinner_standardDeviation);
	}
	
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel label_expectation;
    private javax.swing.JLabel label_standardDeviation;
    private javax.swing.JSpinner spinner_expectation;
    private javax.swing.JSpinner spinner_standardDeviation;
    // End of variables declaration//GEN-END:variables
}