package de.uni.bamberg.wiai.minf.forflow.datagenerator.view.dialog;

import java.awt.Color;
import java.awt.Font;
import java.awt.Frame;
import java.awt.event.ActionEvent;
import java.awt.event.KeyEvent;

import javax.swing.AbstractAction;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.JOptionPane;
import javax.swing.KeyStroke;
import javax.swing.text.BadLocationException;
import javax.swing.text.DefaultStyledDocument;
import javax.swing.text.SimpleAttributeSet;
import javax.swing.text.Style;
import javax.swing.text.StyleConstants;
import javax.swing.text.StyleContext;
import javax.swing.text.StyledDocument;

import org.jdesktop.application.Action;

import de.uni.bamberg.wiai.minf.forflow.datagenerator.controller.worker.GenerateTestData;
import de.uni.bamberg.wiai.minf.forflow.datagenerator.view.DataGeneratorView;
import de.uni.bamberg.wiai.minf.forflow.datagenerator.view.message.Message;;

/**
 * The class represents an dialog showing up at the time when
 * the test data generation starts. With the dialog the system
 * can give feedback about the progress with status messages and
 * information messages. The messages are coloured and have different
 * fonts depending on the importance. This is helpy to get the
 * attention of the user.
 * </p>
 * <font size=6><b>Reference to worker</b></font></br>
 * An important matter is the reference to the background thread.
 * The reference is passed to this dialog by the worker thread itself,
 * so the dialog has the opportunity to pass <i>cancel</i> request
 * directly to the worker. It is important to consider that opportunity,
 * 'cos an user might cancel the job of creating test data any time.
 * If a cancel request is send by the dialog to the worker the reference
 * stored here will become invalid.
 * 
 * @author Michael Munz
 * @version 0.1
 * @since May/12/09
 */
public class GenerateData extends JDialog
{
	/**
	 * ID generated by Eclipse
	 */
	private static final long serialVersionUID = 4107977316923557821L;
	
	/**
	 * a style context object used for the document
	 */
	private StyleContext context = null;
	
	/**
	 * here is the document holding the status information.
	 * We don't set text directly into the text pane, but rather
	 * use the document enables us to add and modify the text.
	 */
	private StyledDocument document = null;
	
	/**
	 * here is a reference to the worker. This is extremely
	 * important, because the user might cancel the process
	 * and therefore the call is passed on to the worker.
	 */
	private GenerateTestData worker = null;
	
	/**
	 * constructor is passed the main frame.
	 * Notice, the main frame is not the {@link DataGeneratorView}.
	 * The <i>DataGeneratorView</i> is the main view for displaying,
	 * but it's itself a subframe of swing's application framework.
	 * 
	 * @param parent
	 * 		the main frame of swing's application framework.
	 */
	public GenerateData(Frame parent)
	{
		super(parent);
		
		this.initBefore();
		
		this.initComponents();
		
		this.initAfter();
	}
	
	/**
	 * a work-around method for Netbeans {@link #initComponents()} method.
	 * It is called before that.
	 */
	private void initBefore()
	{
		this.keyBinding();
		
		this.initStyle();
	}
	
	/**
	 * a work-around method for Netbeans {@link #initComponents()} method.
	 * It is called after that.
	 */
	private void initAfter()
	{
		this.button_ok.setEnabled(false);
	}
	
	/**
	 * does the key binding to this dialog.
	 * To put it more clearly, it registers the <i>Enter</i> key
	 * to this dialog. When pressing it has one of two possible effects.
	 * </p>
	 * <font size=6><b>OK button enabled</b></font></br>
	 * In case the <i>OK</i> button has been enabled by the worker thread,
	 * the test data generation process has been finished successfully.
	 * So the pressing of the <i>Enter</i> key is binded to OK button.
	 * </p>
	 * <font size=6><b>OK button disabled</b></font></br>
	 * It is also possible to press the <i>Enter</i> key at the time
	 * when the OK button is disabled. The call is redirected to the
	 * cancel button and has the effect of canceling the process.
	 */
	private void keyBinding()
	{
		this.getRootPane().getInputMap(JComponent.WHEN_FOCUSED).put(
				KeyStroke.getKeyStroke(KeyEvent.VK_ENTER, 0),
				"ok");
		this.getRootPane().getActionMap().put("ok", new OKAction());
	}
	
	/**
	 * initializes the styles of the document used
	 * by the text pane. Documents are much more useful
	 * and helpful adding and modifying text. Instead of
	 * directly setting the text into the pane a document
	 * will be used.
	 */
	private void initStyle()
	{
		this.context = new StyleContext();
		
		this.document = new DefaultStyledDocument(this.context);
		
		Style style = this.context.getStyle(StyleContext.DEFAULT_STYLE);
		
		StyleConstants.setAlignment(style, StyleConstants.ALIGN_LEFT);
		StyleConstants.setFontSize(style, 14);
	}
	
	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        label_headline = new javax.swing.JLabel();
        progressBar = new javax.swing.JProgressBar();
        button_cancel = new javax.swing.JButton();
        scrollPane = new javax.swing.JScrollPane();
        textPane = new javax.swing.JTextPane(this.document);
        label_progress = new javax.swing.JLabel();
        label_info = new javax.swing.JLabel();
        label_progressInfo = new javax.swing.JLabel();
        button_ok = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(de.uni.bamberg.wiai.minf.forflow.datagenerator.DataGenerator.class).getContext().getResourceMap(GenerateData.class);
        setTitle(resourceMap.getString("Form.title")); // NOI18N
        setModalityType(ModalityType.APPLICATION_MODAL);
        setName("Form"); // NOI18N
        setResizable(false);

        label_headline.setFont(resourceMap.getFont("label_headline.font")); // NOI18N
        label_headline.setText(resourceMap.getString("label_headline.text")); // NOI18N
        label_headline.setName("label_headline"); // NOI18N

        progressBar.setForeground(resourceMap.getColor("progressBar.foreground")); // NOI18N
        progressBar.setName("progressBar"); // NOI18N
        progressBar.setStringPainted(true);
        progressBar.setVerifyInputWhenFocusTarget(false);

        javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance(de.uni.bamberg.wiai.minf.forflow.datagenerator.DataGenerator.class).getContext().getActionMap(GenerateData.class, this);
        button_cancel.setAction(actionMap.get("cancel")); // NOI18N
        button_cancel.setText(resourceMap.getString("button_cancel.text")); // NOI18N
        button_cancel.setName("button_cancel"); // NOI18N

        scrollPane.setName("scrollPane"); // NOI18N

        textPane.setEditable(false);
        textPane.setName("textPane"); // NOI18N
        scrollPane.setViewportView(textPane);

        label_progress.setText(resourceMap.getString("label_progress.text")); // NOI18N
        label_progress.setName("label_progress"); // NOI18N

        label_info.setText(resourceMap.getString("label_info.text")); // NOI18N
        label_info.setName("label_info"); // NOI18N

        label_progressInfo.setText(resourceMap.getString("label_progressInfo.text")); // NOI18N
        label_progressInfo.setName("label_progressInfo"); // NOI18N

        button_ok.setAction(actionMap.get("done")); // NOI18N
        button_ok.setText(resourceMap.getString("button_ok.text")); // NOI18N
        button_ok.setName("button_ok"); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(94, 94, 94)
                        .addComponent(label_headline))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(progressBar, javax.swing.GroupLayout.PREFERRED_SIZE, 380, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(label_progress)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(label_progressInfo))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(label_info))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(121, 121, 121)
                        .addComponent(button_ok)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(button_cancel)))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {button_cancel, button_ok});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(label_headline)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(label_info)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 153, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(label_progress)
                    .addComponent(label_progressInfo))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(progressBar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(button_cancel)
                    .addComponent(button_ok))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * this method cancels the test data generation.
     * The request of canceling the job can't be fulfilled
     * by the view itself. It rather passes it on to the
     * worker thread.
     */
    @Action
    public void cancel()
    {
    	int n = Message.showConfirmDialog(
    			"Do you really wanna cancel the process?"
    			+"\n",
    			"Cancel",
    			JOptionPane.YES_NO_OPTION);
    	
    	/*
    	 * yes = 0;
    	 * no = 1;
    	 */
    	
    	if(n == 0)
    	{
    		this.worker.cancel(true);
    		
    		this.dispose();
    		
    		this.reset();
    	}
    	
    	System.gc();
    }
    
    /**
     * this method is only enabled, when the job has 
     * been finished successfully. The dialog closes
     * by calling this method.
     */
    @Action
    public void done()
    {
    	this.dispose();
    	
    	this.reset();
    }
    
    /**
     * with this method gives the ability to set progress informations.
     * These are messages about how many data sets in total
     * are gonna generated and how many of them are already finished.
     * 
     * @param message
     * 		message about the progress
     */
    public void setProgressInfo(String message)
    {
    	this.label_progressInfo.setText(message);
    }
    
    /**
     * sets the given message into the status information
     * text field. The text field is used to get feedback
     * from the test data generation process.
     * 
     * @param message
     * 		information about the current status and progress
     */
    public void addStatusInformation(String message)
    {
    	try
    	{
    		this.document.insertString(this.document.getLength(), message, null);
    		this.document.insertString(this.document.getLength(), "\n", null);
    	}
    	catch(BadLocationException ble)
    	{
    	}
    }
    
    /**
     * sets the given message into the status information
     * text field. The text field is used to get feedback
     * from the test data generation process. A 2nd parameter
     * allows to set the text colour. This is helpful when
     * important messages are set into the text field. So
     * they get more attention.
     * 
     * @param message
     * 		information about the current status and progress
     * @param textColour
     * 		a text colour to highlight the message.
     * 		Useful for important stuff.
     */
    public void addStatusInformation(String message, Color textColour)
    {
    	SimpleAttributeSet attribute = new SimpleAttributeSet();
    	
    	StyleConstants.setForeground(attribute, textColour);
    	
    	try
    	{
    		this.document.insertString(this.document.getLength(), message, attribute);
    		this.document.insertString(this.document.getLength(), "\n", null);
    	}
    	catch(BadLocationException ble)
    	{
    	}
    }
    
    /**
     * sets the given message into the status information
     * text field. The text field is used to get feedback
     * from the test data generation process. Moreover,
     * this method allows to set the font. It is an alternative
     * to the colour and for highlighting of less important
     * messages or for headlines.
     * 
     * @param message
     * 		information about the current status and progress
     * @param font
     * 		to highlight the message in a different font.
     */
    public void addStatusInformation(String message, Font font)
    {
    	SimpleAttributeSet attribute = new SimpleAttributeSet();
    	
    	StyleConstants.setFontFamily(attribute, font.getFamily());
    	StyleConstants.setFontSize(attribute, font.getSize());
    	StyleConstants.setBold(attribute, font.isBold());
    	StyleConstants.setItalic(attribute, font.isItalic());
    	
    	try
    	{
    		this.document.insertString(this.document.getLength(), message, attribute);
    		this.document.insertString(this.document.getLength(), "\n", null);
    	}
    	catch(BadLocationException ble)
    	{
    	}
    }
    
    /**
     * sets the given message into the status information
     * text field. The text field is used to get feedback
     * from the test data generation process. A further parameter
     * allows to set the text colour. This is helpful when
     * important messages are set into the text field. So
     * they get more attention. The font as the last parameter
     * changes the font to display the message.
     * 
     * @param message
     * 		information about the current status and progress
     * @param textColour
     * 		a text colour to highlight the message.
     * 		Useful for important stuff.
     * @param font
     * 		to highlight the message in a different font.
     */
    public void addStatusInformation(String message, Color textColour, Font font)
    {
    	SimpleAttributeSet attribute = new SimpleAttributeSet();
    	
    	StyleConstants.setFontFamily(attribute, font.getFamily());
    	StyleConstants.setFontSize(attribute, font.getSize());
    	StyleConstants.setBold(attribute, font.isBold());
    	StyleConstants.setItalic(attribute, font.isItalic());
    	StyleConstants.setForeground(attribute, textColour);
    	
    	try
    	{
    		this.document.insertString(this.document.getLength(), message, attribute);
    		this.document.insertString(this.document.getLength(), "\n", null);
    	}
    	catch(BadLocationException ble)
    	{
    	}
    }
    
    /**
     * when the job has been finished successfully,
     * the worker calls this method to enable the <i>ok</i> button.
     * By clicking the button the dialog closes.
     */
    public void setOKButtonEnabled()
    {
    	this.button_ok.setEnabled(true);
    }
    
    /**
     * sets the current value into the progress bar.
     * The method is used by the worker thread to
     * give proper feedback about the progress status.
     * 
     * @param n
     * 		how much progress do we have so far?
     */
    public void setValueProgressBar(int n)
    {
    	this.progressBar.setValue(n);
    }
    
    /**
     * initializes the progress bar with the min & max
     * value and determines if it is visualized as
     * indeterminate or determinate.
     * 
     * @param min
     * 		the minimum value possible
     * @param max
     * 		sets the maximum value
     * @param indeterminate
     * 		is the progress undetermined?
     */
    public void initProgressBar(int min, int max, boolean indeterminate)
    {
    	this.progressBar.setMinimum(min);
    	this.progressBar.setMaximum(max);
    	this.progressBar.setIndeterminate(indeterminate);
    }
    
    /**
     * resets all components to its initial stage.
     */
    public void reset()
    {
    	this.textPane.setText("");
    	this.button_ok.setEnabled(false);
    	this.progressBar.setValue(0);
    	this.progressBar.setIndeterminate(false);
    	this.label_progressInfo.setText("0 of n");
    	
    	DataGeneratorView.getProgressBar().setValue(0);
    	DataGeneratorView.getProgressBar().setIndeterminate(false);
    	
    	System.gc();
    }
    
    /**
     * the reference to the worker thread is extremely
     * important. The user might cancel the process
     * via the dialog. Because the view can't fulfill
     * this request the dialog will pass it on to the
     * controller layer. More exactly to the worker
     * directly.
     * </p>
     * This dialog gets the reference to the worker
     * from the worker thread itself. So a direct call
     * is possible. 
     * 
     * @param worker
     * 		worker thread doing the job in background
     */
    public void setWorkerReference(GenerateTestData worker)
    {
    	this.worker = worker;
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton button_cancel;
    private javax.swing.JButton button_ok;
    private javax.swing.JLabel label_headline;
    private javax.swing.JLabel label_info;
    private javax.swing.JLabel label_progress;
    private javax.swing.JLabel label_progressInfo;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JScrollPane scrollPane;
    private javax.swing.JTextPane textPane;
    // End of variables declaration//GEN-END:variables
    
    /**
     * Enables the dialog to get key binding on the pressing
     * of <i>Enter</i> key without using the mouse.
     * The action event is mapped to both the <i>OK</i> and
     * the <i>Cancel</i> button. The mapping depends highly
     * on the dialog state. If the OK button is not enabled
     * by the worker thread the mapping will cause the cancel
     * action otherwise the OK action.
     * 
     * @author Michael Munz
     * @version 0.1
     * @since May/14/09
     */
    private class OKAction extends AbstractAction
    {
    	/**
		 * ID generated by Eclipse
		 */
		private static final long serialVersionUID = -6723579361578640297L;

		@Override
    	public void actionPerformed(ActionEvent ae)
    	{
    		if(button_ok.isEnabled())
    		{
    			done();
    		}
    		else
    		{
    			cancel();
    		}
    	}
    }
}