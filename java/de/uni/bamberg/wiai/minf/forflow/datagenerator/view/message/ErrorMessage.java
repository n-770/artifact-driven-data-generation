package de.uni.bamberg.wiai.minf.forflow.datagenerator.view.message;

import java.io.IOException;
import java.util.logging.ConsoleHandler;
import java.util.logging.FileHandler;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import javax.swing.JDialog;

import de.uni.bamberg.wiai.minf.forflow.datagenerator.DataGenerator;
import de.uni.bamberg.wiai.minf.forflow.datagenerator.controller.ControllerFactory;
import de.uni.bamberg.wiai.minf.forflow.datagenerator.controller.ControllerImpl;
import de.uni.bamberg.wiai.minf.forflow.datagenerator.controller.log.Log;

import org.jdesktop.application.Action;

/**
 * This class extends behaviour from {@link JDialog} and is used
 * to display any exception that might occur during runtime.
 * The application is based on Java Swing and printing messages
 * to <i>console</i> are not sufficient enough or not the proper
 * way dealing with this. To bridge that gap, a more sophisticated
 * way is desirable and we do this with an error message dialog.
 * The dialog itself can be adjusted in several ways.
 * </p>
 * The message not only is displayed to the user, but it's also
 * possible to create a <i>log</i> file. A flag controls the setting
 * of the log mechanism and it's anytime possible to change it,
 * at runtime, of course.
 * </p>
 * Here an example of such an error dialog. </br>
 * <img src="ErrorMessage.jpg" alt="ErrorMessage.jpg" />
 * 
 * @author Michael Munz
 * @version 0.1
 * @since May/05/09
 */
public final class ErrorMessage extends JDialog
{
	/**
	 * ID generated by Eclipse
	 */
	private static final long serialVersionUID = -6341525628734447015L;
	
	/**
	 * reference of itself
	 */
	private static ErrorMessage errorMessage = null;
	
	/**
	 * a logger to log messages for this error class.
	 */
	private Logger logger = null;
	
	/**
	 * a logger's file handler
	 */
	private FileHandler fileHandler = null;
	
	/**
	 * a logger's console handler
	 */
	private ConsoleHandler consoleHandler = null;
	
	/**
	 * default constructor		
	 */
	private ErrorMessage()
	{
		super(DataGenerator.getApplication().getMainFrame());
		
		this.initBefore();
		
		// used by NetBeans
		this.initComponents();
		
		this.initAfter();
		
		this.setAlwaysOnTop(true);
	}
	
	/**
	 * ErrorMessage class is based on <i>Singelton</i> pattern.
	 * To get an instance you've to call this method. It then
	 * creates an object only once and returns the reference.
	 * 
	 * @return
	 * 		instance of error message
	 */
	public static ErrorMessage getInstance()
	{
		if(errorMessage == null)
		{
			errorMessage = new ErrorMessage();
		}
		
		return errorMessage;
	}
	
	/**
	 * ErrorMessage class is based on <i>Singelton</i> pattern.
	 * To get an instance you've to call this method. It then
	 * creates an object only once and returns the reference.
	 * </p>
	 * The difference to the default constructor is, the logging
	 * mechanism can be changed any time at runtime.
	 * 
	 * @param log
	 * 		sets logging setting
	 * @return
	 * 		instance of error message
	 */
	public static ErrorMessage getInstance(boolean log)
	{
		if(errorMessage == null)
		{
			errorMessage = new ErrorMessage();
		}
		
		ControllerFactory.getController().setLogging(log);
		
		return errorMessage;
	}
	
	/**
	 * work-around of Netbeans {@link #initComponents()} method.
	 * It is called, indeed, before.
	 */
	private void initBefore()
	{
		this.initLogger();
		
		this.initConsoleHandler();
		
		this.initFileHandler();
	}
	
	/**
	 * work-around of Netbeans {@link #initComponents()} method.
	 * This method is called after that.
	 */
	private void initAfter()
	{
	}
	
	/**
	 * initializes the logger
	 */
	private void initLogger()
	{
		// Logger
		this.logger = Logger.getLogger(this.getClass().getName());
		
		this.logger.setLevel(Level.INFO);
	}
	
	/**
	 * creates the console handler for the
	 * Java logger.
	 * Console handler prints the log event
	 * to standard console.
	 */
	private void initConsoleHandler()
	{
		// console handler
		this.consoleHandler = new ConsoleHandler();
		
		this.consoleHandler.setFormatter(new SimpleFormatter());
		
		this.logger.addHandler(this.consoleHandler);
	}
	
	/**
	 * creates the file handler and registers
	 * to Java's logger.
	 * The file handler is used to logging files.
	 */
	private void initFileHandler()
	{
		// FileHandler
		try
		{
			this.fileHandler = new FileHandler(Log.LOG_FILE,
											   Log.LOG_FILE_LIMIT,
											   Log.LOG_FILE_NO,
											   true);
			
			this.fileHandler.setFormatter(new SimpleFormatter());
			
			this.logger.addHandler(fileHandler);
		}
		catch(SecurityException se)
		{
			this.logging(se, "SecurityException", Level.SEVERE, this.logger);
		}
		catch(IOException ioe)
		{
			this.logging(ioe, "IOException", Level.SEVERE, this.logger);
		}
	}
	
	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        button_ok = new javax.swing.JButton();
        panel_error = new javax.swing.JPanel();
        scrollPane_error = new javax.swing.JScrollPane();
        textPane_error = new javax.swing.JTextPane();
        button_close = new javax.swing.JButton();

        setModalityType(ModalityType.APPLICATION_MODAL);
        setName("Form"); // NOI18N
        setResizable(false);

        javax.swing.ActionMap actionMap = org.jdesktop.application.Application.getInstance(de.uni.bamberg.wiai.minf.forflow.datagenerator.DataGenerator.class).getContext().getActionMap(ErrorMessage.class, this);
        button_ok.setAction(actionMap.get("ok")); // NOI18N
        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(de.uni.bamberg.wiai.minf.forflow.datagenerator.DataGenerator.class).getContext().getResourceMap(ErrorMessage.class);
        button_ok.setText(resourceMap.getString("button_ok.text")); // NOI18N
        button_ok.setName("button_ok"); // NOI18N

        panel_error.setName("panel_error"); // NOI18N

        scrollPane_error.setName("scrollPane_error"); // NOI18N

        textPane_error.setEditable(false);
        textPane_error.setFont(resourceMap.getFont("textPane_error.font")); // NOI18N
        textPane_error.setForeground(resourceMap.getColor("textPane_error.foreground")); // NOI18N
        textPane_error.setName("textPane_error"); // NOI18N
        textPane_error.setSelectedTextColor(resourceMap.getColor("textPane_error.selectedTextColor")); // NOI18N
        scrollPane_error.setViewportView(textPane_error);

        javax.swing.GroupLayout panel_errorLayout = new javax.swing.GroupLayout(panel_error);
        panel_error.setLayout(panel_errorLayout);
        panel_errorLayout.setHorizontalGroup(
            panel_errorLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(scrollPane_error, javax.swing.GroupLayout.DEFAULT_SIZE, 518, Short.MAX_VALUE)
        );
        panel_errorLayout.setVerticalGroup(
            panel_errorLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(scrollPane_error, javax.swing.GroupLayout.DEFAULT_SIZE, 251, Short.MAX_VALUE)
        );

        button_close.setAction(actionMap.get("closeDialog")); // NOI18N
        button_close.setText(resourceMap.getString("button_close.text")); // NOI18N
        button_close.setName("button_close"); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(panel_error, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(203, 203, 203)
                        .addComponent(button_ok)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(button_close)))
                .addContainerGap())
        );

        layout.linkSize(javax.swing.SwingConstants.HORIZONTAL, new java.awt.Component[] {button_close, button_ok});

        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(panel_error, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(button_ok)
                    .addComponent(button_close))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * Literally any subclass of throwable can be passed
     * down here. With the exception object an message
     * dialog will be created with as much information
     * as available.
     * 
     * @param e
     * 		superclass of all errors and exceptions
     * @param title
     * 		the headline for the error dialog
     */
    public void printMessage(Throwable e, String title)
    {
    	this.printMessage(null, e, null, title, null);
    }
    
    /**
     * Literally any subclass of throwable can be passed
     * down here. With the exception object an message
     * dialog will be created with as much information
     * as available.
     * 
     * @param e
     * 		superclass of all errors and exceptions
     * @param title
     * 		the headline for the error dialog
     * @param level
     * 		defines the logging level. It's a mechanism to make
     * 		logging very flexible and cots very little at runtime
     * 		when logging code is not used, e.g. in production.
     * 		Available levels are:
     * 		<ul>
     * 			<li><b>ALL</b></li> enables logging of all records
     * 			<li><b>SEVERE</b></li> intended for extremely important messages (<i>highest value</i>)
     * 			<li><b>WARNING</b></li> intended for warning messages
     * 			<li><b>INFO</b></li> informational runtime messages
     * 			<li><b>CONFIG</b></li> informational messages about config/setup
     * 			<li><b>FINE</b></li> greater detail; used for debugging
     * 			<li><b>FINER</b></li> even greater detail
     * 			<li><b>FINEST</b></li> greatest detail (<i>lowest value</i>)
     * 			<li><b>OFF</b></li> turns logging off
     * 		</ul>
     */
    public void printMessage(Throwable e, String title, Level level)
    {
    	this.printMessage(null, e, null, title, level);
    }
    
    /**
     * Literally any subclass of throwable can be passed
     * down here. With the exception object an message
     * dialog will be created with as much information
     * as available.
     * 
     * @param e
     * 		superclass of all errors and exceptions
     * @param message
     * 		customized messages can be passed down here.
     * @param title
     * 		the headline for the error dialog
     */
    public void printMessage(Throwable e, String message, String title)
    {
    	this.printMessage(null, e, message, title, null);
    }
    
    /**
     * Literally any subclass of throwable can be passed
     * down here. With the exception object an message
     * dialog will be created with as much information
     * as available.
     * 
     * @param e
     * 		superclass of all errors and exceptions
     * @param message
     * 		customized messages can be passed down here.
     * @param title
     * 		the headline for the error dialog
     * @param level
     * 		defines the logging level. It's a mechanism to make
     * 		logging very flexible and cots very little at runtime
     * 		when logging code is not used, e.g. in production.
     * 		Available levels are:
     * 		<ul>
     * 			<li><b>ALL</b></li> enables logging of all records
     * 			<li><b>SEVERE</b></li> intended for extremely important messages (<i>highest value</i>)
     * 			<li><b>WARNING</b></li> intended for warning messages
     * 			<li><b>INFO</b></li> informational runtime messages
     * 			<li><b>CONFIG</b></li> informational messages about config/setup
     * 			<li><b>FINE</b></li> greater detail; used for debugging
     * 			<li><b>FINER</b></li> even greater detail
     * 			<li><b>FINEST</b></li> greatest detail (<i>lowest value</i>)
     * 			<li><b>OFF</b></li> turns logging off
     * 		</ul>
     */
    public void printMessage(Throwable e, String message, String title, Level level)
    {
    	this.printMessage(null, e, message, title, level);
    }
    
    /**
	 * It's passed the thread <i>t</i> and the corresponding error
     * or exception <i>e</i>. The thread is where the exception 
     * has occurred. That could be the EDT or any other thread.
     * The object <i>e</i> is any throwable. Throwable is the superclass
     * of any error or exception that can occur.
	 * 
	 * @param t
	 * 		either the EDT or any other thread, like
	 * 		worker threads.
	 * @param e
	 * 		superclass of all errors and exceptions
	 * @param title
	 * 		the headline for the error dialog
	 */
	public void printMessage(Thread t, Throwable e, String title)
	{
		this.printMessage(t, e, null, title, null);
	}
    
	 /**
	 * It's passed the thread <i>t</i> and the corresponding error
     * or exception <i>e</i>. The thread is where the exception 
     * has occurred. That could be the EDT or any other thread.
     * The object <i>e</i> is any throwable. Throwable is the superclass
     * of any error or exception that can occur.
	 * 
	 * @param t
	 * 		either the EDT or any other thread, like
	 * 		worker threads.
	 * @param e
	 * 		superclass of all errors and exceptions
	 * @param title
	 * 		the headline for the error dialog
	 * @param level
	 * 		defines the logging level. It's a mechanism to make
     * 		logging very flexible and cots very little at runtime
     * 		when logging code is not used, e.g. in production.
     * 		Available levels are:
     * 		<ul>
     * 			<li><b>ALL</b></li> enables logging of all records
     * 			<li><b>SEVERE</b></li> intended for extremely important messages (<i>highest value</i>)
     * 			<li><b>WARNING</b></li> intended for warning messages
     * 			<li><b>INFO</b></li> informational runtime messages
     * 			<li><b>CONFIG</b></li> informational messages about config/setup
     * 			<li><b>FINE</b></li> greater detail; used for debugging
     * 			<li><b>FINER</b></li> even greater detail
     * 			<li><b>FINEST</b></li> greatest detail (<i>lowest value</i>)
     * 			<li><b>OFF</b></li> turns logging off
     * 		</ul>
	 */
	public void printMessage(Thread t, Throwable e, String title, Level level)
	{
		this.printMessage(t, e, null, title, level);
	}
	
    /**
     * It's passed the thread <i>t</i> and the corresponding error
     * or exception <i>e</i>. The thread is where the exception 
     * has occurred. That could be the EDT or any other thread.
     * The object <i>e</i> is any throwable. Throwable is the superclass
     * of any error or exception that can occur.
     * There is a 3rd parameter called <i>message</i>. It is optional and
     * can contain any detailed description about the failure like the stackTrace
     * or any customized description. 
     * 
     * @param t
	 * 		either the EDT or any other thread, like
	 * 		worker threads.
	 * @param e
	 * 		superclass of all errors and exceptions
     * @param message
     * 		as the parameter already says: you've got the opportunity
     * 		to put same custom information here in.
     * @param title
     * 		the headline for the error dialog
     * @param level
     * 		defines the logging level. It's a mechanism to make
     * 		logging very flexible and cots very little at runtime
     * 		when logging code is not used, e.g. in production.
     * 		Available levels are:
     * 		<ul>
     * 			<li><b>ALL</b></li> enables logging of all records
     * 			<li><b>SEVERE</b></li> intended for extremely important messages (<i>highest value</i>)
     * 			<li><b>WARNING</b></li> intended for warning messages
     * 			<li><b>INFO</b></li> informational runtime messages
     * 			<li><b>CONFIG</b></li> informational messages about config/setup
     * 			<li><b>FINE</b></li> greater detail; used for debugging
     * 			<li><b>FINER</b></li> even greater detail
     * 			<li><b>FINEST</b></li> greatest detail (<i>lowest value</i>)
     * 			<li><b>OFF</b></li> turns logging off
     * 		</ul>
     */
	public void printMessage(Thread t,
							 Throwable e,
							 String message,
							 String title,
							 Level level)
	{
		this.setTitle(title);
		
		StringBuffer sb = new StringBuffer();
		
		// custom message might be null
		if(message != null)
		{
			sb.append(message +"\n\n");
		}
		
		// might be null, so check
		if(t != null)
		{
			sb.append(t.getName() +"\n");
		}
		
		for(int i=0; i<e.getStackTrace().length; i++)
		{
			StackTraceElement ste = e.getStackTrace()[i];
			
			sb.append(ste.toString() +"\n\n");
		}
		
		this.textPane_error.setText(sb.toString());
		
		this.logging(e, message, level, this.logger);
		
		this.setVisible(true);
	}
	
	/**
	 * this method refers to the <i>OK</i> button.
	 * In contrast to {@link #closeDialog()} it
	 * shuts down the whole system.
	 */
    @Action
    public void ok()
    {
    	DataGenerator.getApplication().exit();
    }

    /**
     * this method refers to the <i>Close</i> button.
     * It just closes the caused message dialog, but
     * doesn't shut down the system.
     */
    @Action
    public void closeDialog()
    {
    	this.dispose();
    	
    	this.reset();
    }
    
    /**
     * gets the current logging setting.
     * The flag is actually not stored here, but
     * in the controller layer.
     * This method gets the flag from there and
     * returns it to the invoker.
     * 
     * @return
     * 		logging?
     */
    public boolean isLoggingEnabled()
    {
    	return ControllerFactory.getController().isLogging();
    }
    
    /**
     * this method checks whether logging flag has been
     * initialized.
     * 
     * @return
     * 		boolean object or null
     */
    private Boolean isLoggingSet()
    {
    	ControllerImpl controller = (ControllerImpl) ControllerFactory.getController();
    	
    	return controller.getLogging();
    }
    
    /**
	 * invokes the logging mechanism when
	 * logging has been enabled. The class is
	 * designed that the flag can change anytime
	 * at runtime. If logging level is not specified
	 * the default value <i>Level.Info</i> is used.
	 * </p>
	 * Remember, logging involves I/O bound processes,
	 * so the actual logging isn't done here.
	 * It is passed to the controller layer so we
	 * pass the logger too. 
	 * 
	 * @param e
	 * 		superclass of all errors and exceptions
     * @param message
     * 		as the parameter already says: you've got the opportunity
     * 		to put same custom information here in.
     * @param level
     * 		defines the logging level. It's a mechanism to make
     * 		logging very flexible and cots very little at runtime
     * 		when logging code is not used, e.g. in production.
     * 		Available levels are:
     * 		<ul>
     * 			<li><b>ALL</b></li> enables logging of all records
     * 			<li><b>SEVERE</b></li> intended for extremely important messages (<i>highest value</i>)
     * 			<li><b>WARNING</b></li> intended for warning messages
     * 			<li><b>INFO</b></li> informational runtime messages
     * 			<li><b>CONFIG</b></li> informational messages about config/setup
     * 			<li><b>FINE</b></li> greater detail; used for debugging
     * 			<li><b>FINER</b></li> even greater detail
     * 			<li><b>FINEST</b></li> greatest detail (<i>lowest value</i>)
     * 			<li><b>OFF</b></li> turns logging off
     * 		</ul>
     * @param logger
     * 		the logger object which does the logging
	 */
	private void logging(Throwable e, String message, Level level, Logger logger)
	{
		// no startup phase
		if(this.isLoggingSet() != null)
		{
			// logging enabled & level set
			if((ControllerFactory.getController().isLogging()) && (level != null))
			{
				// customized level
				ControllerFactory.getControllerBackgroundTask().log(level, message, e, logger);
			}
			else
			{
				// default
				ControllerFactory.getControllerBackgroundTask().log(Level.INFO, message, e, logger);
			}
		}
	}
	
    /**
     * When only the message dialog has been disposed,
     * we reset the dialog to its initial state.
     * Otherwise it would still contain the previous
     * thrown exception when it pops up again.
     * And that is definitely not what we want.
     */
    private void reset()
    {
    	this.textPane_error.setText("");
    }
	
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton button_close;
    private javax.swing.JButton button_ok;
    private javax.swing.JPanel panel_error;
    private javax.swing.JScrollPane scrollPane_error;
    private javax.swing.JTextPane textPane_error;
    // End of variables declaration//GEN-END:variables
}